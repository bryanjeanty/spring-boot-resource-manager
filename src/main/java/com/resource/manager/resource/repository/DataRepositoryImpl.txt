package com.resource.manager.resource.repository;

import java.sql.Statement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import com.resource.manager.resource.entity.Data;

public class DataRepositoryImpl implements DataRepositoryCustom {

    @PersistenceContext
    private EntityManager entityManager;

    private Connection conn = null;
    private Statement stmt = null;
    private PreparedStatement preStmt = null;
    private ResultSet rSet = null;
    private ResultSetMetaData rsmd = null;

    private final String connectUrl = System.getenv("MSSQL_AWS_URL") + ";" + System.getenv("MSSQL_AWS_USER") + ";"
            + System.getenv("MSSQL_AWS_PASS");

    @Override
    public HashMap<Integer, Boolean> doesTableExist(Data data) {
        int refTabVerNum = data.getVersionNumber();

        String selectQuery = "SELECT ReferenceTableVersionNumber FROM dataTables WHERE ReferenceTableVersionNumber = '"
                + refTabVerNum + "'";

        HashMap<Integer, Boolean> myMap = new HashMap<Integer, Boolean>(1);

        myMap.put(refTabVerNum, true);

        try {
            conn = DriverManager.getConnection(connectUrl);

            stmt = conn.createStatement();
            rSet = stmt.executeQuery(selectQuery);

            while (rSet.next()) {
                if (refTabVerNum == rSet.getInt("ReferenceTableVersionNumber")) {
                    myMap.replace(refTabVerNum, false);
                }
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (stmt != null && conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }

        return myMap;
    }

    @Override
    public int createTable(HashMap<Integer, Boolean> myMap, String[] columns) {
        int refTabVerNum = 0;

        for (HashMap.Entry<Integer, Boolean> entry : myMap.entrySet()) {
            if (entry.getValue() == true) {
                return entry.getKey();
            } else {
                refTabVerNum = entry.getKey();
            }
        }

        String createQuery = "CREATE TABLE data-" + refTabVerNum + "(Id INT IDENTITY(1,1) NOT NULL PRIMARY KEY,"
                + "Name VARCHAR(150)," + "Code INT," + "VersionNumber INT NOT NULL,";

        try {
            conn = DriverManager.getConnection(connectUrl);

            for (int i = 0; i < columns.length; i++) {
                createQuery += "\n" + columns[i] + "VARCHAR";
                if (i != (columns.length - 1)) {
                    createQuery += ",";
                } else {
                    createQuery += ");";
                }
            }

            preStmt = conn.prepareStatement(createQuery);
            preStmt.executeUpdate();

        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (stmt != null && conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }
        return refTabVerNum;
    }

    @Override
    public ArrayList<Data> getDataFromDatabase(String query) {
        ArrayList<Data> dataList = null;
        try {
            conn = DriverManager.getConnection(connectUrl);
            stmt = conn.createStatement();
            rSet = stmt.executeQuery(query);
            rsmd = rSet.getMetaData();

            int colCount = rsmd.getColumnCount();
            Data myData = null;
            dataList = new ArrayList<Data>();
            int count = 0;

            while (rSet.next()) {
                myData = new Data();
                for (int i = 0; i < colCount; i++) {
                    switch (rsmd.getColumnName(i)) {
                    case "Id":
                        myData.setId(rSet.getInt("Id"));
                        continue;
                    case "Name":
                        myData.setName(rSet.getString("Name"));
                        continue;
                    case "Code":
                        myData.setCode(rSet.getInt("Code"));
                        continue;
                    case "VersionNumber":
                        myData.setVersionNumber(rSet.getInt("VersionNumber"));
                        continue;
                    default:
                        String colNames = myData.getColumnNames();
                        colNames += ", " + rsmd.getColumnName(i);
                        myData.setColumnNames(colNames);

                        String colValues = myData.getColumnValues();
                        colValues += ", " + rSet.getString(rsmd.getColumnName(i));
                        myData.setColumnValues(colValues);
                        continue;
                    }
                }
                dataList.add(count, myData);
                count++;
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }
        return dataList;
    }

    @Override
    public Data putDataIntoDatabase(String query) {
        Data myData = new Data();
        try {
            conn = DriverManager.getConnection(connectUrl);
            preStmt = conn.prepareStatement(query);
            rSet = preStmt.executeQuery();
            rsmd = rSet.getMetaData();
            int colCount = rsmd.getColumnCount();

            while (rSet.next()) {
                for (int i = 0; i < colCount; i++) {
                    switch (rsmd.getColumnName(i)) {
                    case "Id":
                        myData.setId(rSet.getInt("Id"));
                        continue;
                    case "Name":
                        myData.setName(rSet.getString("Name"));
                        continue;
                    case "Code":
                        myData.setCode(rSet.getInt("Code"));
                        continue;
                    case "VersionNumber":
                        myData.setVersionNumber(rSet.getInt("VersionNumber"));
                        continue;
                    default:
                        String colNames = myData.getColumnNames();
                        colNames += ", " + rsmd.getColumnName(i);
                        myData.setColumnNames(colNames);

                        String colValues = myData.getColumnValues();
                        colValues += ", " + rSet.getString(rsmd.getColumnName(i));
                        myData.setColumnValues(colValues);
                        continue;
                    }
                }
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }

        return myData;
    }

    @Override
    public Data createRecordByVersionNumber(int versionNumber, Data data) {
        String insertQuery = "INSERT INTO data-" + versionNumber + " (Name, Code, VersionNumber";
        if (!(data.getColumnNames().equals(null) || data.getColumnNames().equals(""))) {
            String[] columnNamesArray = data.getColumnNames().split(", ");
            String[] columnValuesArray = data.getColumnValues().split(", ");

            for (int i = 0; i < columnNamesArray.length; i++) {
                insertQuery += ", " + columnNamesArray[i];
            }
            insertQuery += ") VALUES (" + data.getName() + ", " + data.getCode() + ", " + versionNumber;

            for (int i = 0; i < columnValuesArray.length; i++) {
                insertQuery += ", " + columnValuesArray[i];
            }
            insertQuery += ");";
        } else {
            insertQuery += ") VALUES (" + data.getName() + ", " + data.getCode() + ", " + versionNumber + ");";
        }

        return putDataIntoDatabase(insertQuery);
    }

    @Override
    public ArrayList<Data> getAllDataByVersionNumber(int versionNumber) {
        String selectQuery = "SELECT * FROM data-" + versionNumber;
        return getDataFromDatabase(selectQuery);
    }

    @Override
    public ArrayList<Data> getDataByVersionNumberAndId(int versionNumber, int dataId) {
        String selectQuery = "SELECT * FROM data-" + versionNumber + " WHERE Id='" + dataId + "'";
        return getDataFromDatabase(selectQuery);
    }

    @Override
    public Data updateRecordByVersionNumberAndId(int versionNumber, int dateId, Data data) {
        int dataId = dateId;
        String updateQuery = "UPDATE data-" + versionNumber + " SET Name ='" + data.getName() + "', Code='"
                + data.getCode() + "', VersionNumber='" + versionNumber + "'";
        if (!(data.getColumnNames().equals(null) || data.getColumnNames().equals(""))) {
            String[] columnNamesArray = data.getColumnNames().split(", ");
            String[] columnValuesArray = data.getColumnValues().split(", ");

            for (int i = 0; i < columnNamesArray.length; i++) {
                updateQuery += ", " + columnNamesArray[i] + "='" + columnValuesArray[i] + "'";
            }
        }
        updateQuery += "WHERE Id=" + dataId;
        return putDataIntoDatabase(updateQuery);
    }

    @Override
    public int destroyByVersionNumber(int versionNumber, int dataId) {
        String deleteQuery = "DELETE FROM data-" + versionNumber + "WHERE Id='" + dataId + "'";
        int rowsAffected = 0;
        try {
            conn = DriverManager.getConnection(connectUrl);
            preStmt = conn.prepareStatement(deleteQuery);
            rowsAffected = preStmt.executeUpdate();
        } catch (SQLException ex) {
            ex.printStackTrace();
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException ex) {
                    ex.printStackTrace();
                }
            }
        }

        return rowsAffected;
    }
}